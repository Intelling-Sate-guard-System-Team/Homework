# -*- coding: gbk -*-
from __future__ import division
import matplotlib.pyplot as plt
import cv2
import os,glob
import numpy as np
from PIL import Image
from keras.applications.imagenet_utils import preprocess_input
from keras.models import load_model
from keras.preprocessing import image
from Parking import Parking
import pickle


cwd = os.getcwd()

def img_process(test_images,park):
    #去除背景
    white_yellow_images = list(map(park.select_rgb_white_yellow,test_images))  # map(func,case) 对case使用func
    park.show_images(white_yellow_images)
    #灰度图
    gray_images = list(map(park.convert_gray_scale,white_yellow_images))
    park.show_images(gray_images)
    #边缘检测
    edge_images = list(map(park.detect_edges,gray_images))
    park.show_images(edge_images)
    #去除不需要的区域，保留停车场区域
    roi_images = list(map(park.select_region,edge_images))
    park.show_images(roi_images)
    # 检测直线，根据直线来检测停车位位置
    list_of_lines = list(map(park.hough_lines,roi_images))
    # 画出停车位直线
    line_iamges = []
    for image,lines in zip(test_images,list_of_lines):
        line_iamges.append(park.draw_lines(image,lines))
    park.show_images(line_iamges)
    # 画出停车位每列的矩形框，并给停车位标序号
    rect_images = []   # 画好的图
    rect_coords = []   # 每列的位置
    for image,lines in zip(test_images,list_of_lines):
        new_image,rects = park.identify_blocks(image,lines)
        rect_images.append(new_image)
        rect_coords.append(rects)
    park.show_images(rect_images)
    # 切分每列的停车位
    delineated = []
    spot_pos = []  #车位序号
    for image,rects in zip(test_images,rect_coords):
        new_image, spot_dict = park.draw_parking(image, rects)
        delineated.append(new_image)
        spot_pos.append(spot_dict)
    park.show_images(delineated)

    final_spot_dict = spot_pos[1]
    #将车位的坐标位置及序号保存
    with open('spot_dict.pickle','wb') as f:
        pickle.dump(final_spot_dict,f,protocol=pickle.HIGHEST_PROTOCOL)
    # 准备训练网络的车位数据集
    park.save_images_for_cnn(test_images[0],final_spot_dict)

    return final_spot_dict

def keras_model(weights_path):
    model = load_model(weights_path)
    return model

def img_test(test_images,final_spot_dict,model,class_dict):
    for i in range(len(test_images)):
        predicted_images = park.predict_on_image(test_images[i],final_spot_dict,model,class_dict)

def video_test(video_name,final_spot_dict,model,class_dictionary):
    name = video_name
    # cap = cv2.VideoCapture(name)
    park.predict_on_video(name,final_spot_dict,model,class_dictionary,ret=True)

if __name__ == "__main__":
    # 准备测试图片
    test_images = [plt.imread(path) for path in glob.glob('test_images/*.jpg')]
    # 保存训练好的模型中的权重参数
    weights_path = 'car1.h5'

    video_name = 'parking_video.mp4'

    # 停车位类别：空or占用
    class_dict = {}
    class_dict[0] = 'empty'
    class_dict[1] = 'occupied'

    park = Parking()
    # 打开测试图像
    park.show_images(test_images)

    # 图像预处理
    final_spot_dict = img_process(test_images,park)

    #用模型训练
    model = keras_model(weights_path)
    img_test(test_images,final_spot_dict,model,class_dict)
    video_test(video_name,final_spot_dict,model,class_dict)